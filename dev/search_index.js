var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains auto-generated documentation for all public symbols with docstrings in HTMLForge.","category":"section"},{"location":"api/#All-Documented-Symbols","page":"API Reference","title":"All Documented Symbols","text":"","category":"section"},{"location":"api/#HTMLForge.VALID_SWAP_STYLES","page":"API Reference","title":"HTMLForge.VALID_SWAP_STYLES","text":"VALID_SWAP_STYLES\n\nThe set of valid swap styles for hx-swap.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Base.getindex-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"Base.getindex","text":"getindex(elem::HTMLElement, key::Union{AbstractString, Symbol})\n\nGet the attribute with the given key from an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{HTMLElement, Int64}","page":"API Reference","title":"Base.getindex","text":"getindex(elem::HTMLElement, i::Int)\n\nGet the ith child of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{HTMLElement}","page":"API Reference","title":"Base.length","text":"length(elem::HTMLElement)\n\nGet the length of elem's children.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{HTMLText}","page":"API Reference","title":"Base.length","text":"length:text::HTMLText)\n\nGet the length of text content.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{HTMLElement, HTMLNode}","page":"API Reference","title":"Base.push!","text":"push!(elem::HTMLElement, val::HTMLElement)\n\nPush a child onto an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{HTMLElement, AbstractString, Union{AbstractString, Symbol}}","page":"API Reference","title":"Base.setindex!","text":"setindex!(elem::HTMLElement, val::AbstractString, key::Union{AbstractString, Symbol})\n\nSet the attribute with the given key on an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{HTMLElement, HTMLNode, Any}","page":"API Reference","title":"Base.setindex!","text":"setindex!(elem::HTMLElement, val::HTMLElement, i::Integer)\n\nSet the ith child of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.addclass!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.addclass!","text":"addclass!(elem::HTMLElement, cls::AbstractString)\n\nAdds the class cls to elem.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.applyif!-Tuple{Function, Function, HTMLDocument}","page":"API Reference","title":"HTMLForge.applyif!","text":"applyif!(condition::Function, f!::Function, doc::HTMLDocument)\n\nApply f! to all elements (nested included) in doc for which condition is true.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.applyif!-Tuple{Function, Function, HTMLElement}","page":"API Reference","title":"HTMLForge.applyif!","text":"applyif!(condition::Function, f!::Function, elem::HTMLElement)\n\nApply f! to all elements (nested included) in elem for which condition is true.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.attributevalidation-Tuple{AbstractString}","page":"API Reference","title":"HTMLForge.attributevalidation","text":"attributevalidation(attr::AbstractString)\n\nValidate if attr is a valid HTML attribute name according to HTML specifications.\n\nAttribute names must consist of one or more characters other than space characters, NULL, quotes, apostrophes, greater-than signs, forward slashes, equals signs, control characters, and any characters not defined by Unicode.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.attrs-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.attrs","text":"attrs(elem::HTMLElement) :: Dict{String, String}\n\nGet the attributes of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.breadthfirst-Tuple{Any}","page":"API Reference","title":"HTMLForge.breadthfirst","text":"breadthfirst(node)\n\nReturn a breadth-first iterator over the tree rooted at node.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.classvaluevalidation-Tuple{AbstractString}","page":"API Reference","title":"HTMLForge.classvaluevalidation","text":"classvaluevalidation(class::AbstractString)\n\nCSS class values validation.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.findfirst-Tuple{Function, HTMLDocument}","page":"API Reference","title":"HTMLForge.findfirst","text":"findfirst(f::Function, doc::HTMLDocument) :: Union{HTMLElement, Nothing}\n\nFind the first (PreOrderDFS) element in doc for which f is true.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.findfirst-Tuple{Function, HTMLElement}","page":"API Reference","title":"HTMLForge.findfirst","text":"findfirst(f::Function, elem::HTMLElement) :: Union{HTMLElement, Nothing}\n\nFind the first (PreOrderDFS) element in elem for which f is true.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.getattr","page":"API Reference","title":"HTMLForge.getattr","text":"getattr(elem::HTMLElement, name::AbstractString, default=nothing) :: Union{String, Nothing}\n\nGet the value of an attribute of an element or default if not present.\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.getbyid-Tuple{HTMLDocument, AbstractString}","page":"API Reference","title":"HTMLForge.getbyid","text":"getbyid(doc::HTMLDocument, id::AbstractString) :: Union{HTMLElement, Nothing}\n\nGet the element with the given id from doc.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.getbyid-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.getbyid","text":"getbyid(elem::HTMLElement, id::AbstractString) :: Union{HTMLElement, Nothing}\n\nGet the element with the given id from elem.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hasattr-Tuple{HTMLElement, Union{AbstractString, Symbol}}","page":"API Reference","title":"HTMLForge.hasattr","text":"hasattr(elem::HTMLElement, name::AbstractString) :: Bool\n\nCheck whether an element has an attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hasclass-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hasclass","text":"hasclass(elem::HTMLElement, cls::AbstractString)\n\nReturns true if elem has the class cls.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxattr!-Tuple{HTMLElement, Union{AbstractString, Symbol}, AbstractString}","page":"API Reference","title":"HTMLForge.hxattr!","text":"hxattr!(el::HTMLElement, attr::Union{AbstractString,Symbol}, value::AbstractString) -> HTMLElement\n\nSet an arbitrary htmx attribute on an HTMLElement in place. The data-hx- prefix is added automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxboost!","page":"API Reference","title":"HTMLForge.hxboost!","text":"hxboost!(el::HTMLElement, value::AbstractString=\"true\") -> HTMLElement\n\nAdd an hx-boost attribute to progressively enhance links and forms to use AJAX.\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxconfirm!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxconfirm!","text":"hxconfirm!(el::HTMLElement, message::AbstractString) -> HTMLElement\n\nAdd an hx-confirm attribute that shows a confirm() dialog before issuing the request.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxdelete!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxdelete!","text":"hxdelete!(el::HTMLElement, url::AbstractString) -> HTMLElement\n\nAdd an hx-delete attribute to an HTMLElement in place and return the modified element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxdisable!-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.hxdisable!","text":"hxdisable!(el::HTMLElement) -> HTMLElement\n\nAdd an hx-disable attribute to prevent htmx from processing this element and its children. Useful for including untrusted user content.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxdisabledelt!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxdisabledelt!","text":"hxdisabledelt!(el::HTMLElement, selector::AbstractString) -> HTMLElement\n\nAdd an hx-disabled-elt attribute to disable the specified elements during a request.\n\nselector is a CSS selector for elements that should get the HTML disabled attribute while a request is in flight (e.g., \"this\", \"closest button\", \"#submit-btn\").\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxdisinherit!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxdisinherit!","text":"hxdisinherit!(el::HTMLElement, attrs::AbstractString) -> HTMLElement\n\nAdd an hx-disinherit attribute to disable automatic attribute inheritance for child nodes.\n\nattrs can be \"*\" to disable all, or a space-separated list of attribute names (e.g., \"hx-target hx-swap\").\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxencoding!","page":"API Reference","title":"HTMLForge.hxencoding!","text":"hxencoding!(el::HTMLElement, encoding::AbstractString=\"multipart/form-data\") -> HTMLElement\n\nAdd an hx-encoding attribute to change the request encoding type.\n\nSet to \"multipart/form-data\" for file uploads.\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxext!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxext!","text":"hxext!(el::HTMLElement, extensions::AbstractString) -> HTMLElement\n\nAdd an hx-ext attribute to enable htmx extensions for this element and its children.\n\nMultiple extensions can be comma-separated (e.g., \"response-targets,head-support\"). Use \"ignore:<ext-name>\" to disable an inherited extension.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxget!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxget!","text":"hxget!(el::HTMLElement, url::AbstractString) -> HTMLElement\n\nAdd an hx-get attribute to an HTMLElement in place and return the modified element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxheaders!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxheaders!","text":"hxheaders!(el::HTMLElement, json::AbstractString) -> HTMLElement\n\nAdd an hx-headers attribute to include additional headers with the request.\n\njson should be a JSON-formatted string, e.g., \"{\"X-CSRF-Token\": \"abc123\"}\".\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxhistory!","page":"API Reference","title":"HTMLForge.hxhistory!","text":"hxhistory!(el::HTMLElement, value::AbstractString=\"false\") -> HTMLElement\n\nAdd an hx-history attribute. Set to \"false\" to prevent sensitive data on this page from being saved to the browser's history cache (localStorage).\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxhistoryelt!-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.hxhistoryelt!","text":"hxhistoryelt!(el::HTMLElement) -> HTMLElement\n\nAdd an hx-history-elt attribute to mark this element as the snapshot source/target for history navigation (instead of the default body).\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxinclude!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxinclude!","text":"hxinclude!(el::HTMLElement, selector::AbstractString) -> HTMLElement\n\nAdd an hx-include attribute to include values of other elements in the request.\n\nselector is a CSS selector indicating the elements whose values should be included.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxindicator!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxindicator!","text":"hxindicator!(el::HTMLElement, selector::AbstractString) -> HTMLElement\n\nAdd an hx-indicator attribute specifying which element receives the htmx-request class during a request (to show a loading indicator).\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxinherit!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxinherit!","text":"hxinherit!(el::HTMLElement, attrs::AbstractString) -> HTMLElement\n\nAdd an hx-inherit attribute to explicitly enable attribute inheritance for child nodes when htmx.config.disableInheritance is set to true.\n\nattrs can be \"*\" to enable all, or a space-separated list of attribute names (e.g., \"hx-target hx-swap\").\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxon!-Tuple{HTMLElement, AbstractString, AbstractString}","page":"API Reference","title":"HTMLForge.hxon!","text":"hxon!(el::HTMLElement, event::AbstractString, script::AbstractString) -> HTMLElement\n\nAdd an hx-on:<event> attribute to handle events with inline scripts.\n\nThe event name supports both htmx events (e.g., \"htmx:before-request\") and standard DOM events (e.g., \"click\").\n\nNote: uses the data-hx-on:<event> form for HTML spec compliance.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxparams!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxparams!","text":"hxparams!(el::HTMLElement, value::AbstractString) -> HTMLElement\n\nAdd an hx-params attribute to filter the parameters submitted with a request.\n\nSupported values: \"*\" (all), \"none\", a comma-separated list of param names, or \"not <param-list>\" to exclude specific params.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxpatch!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxpatch!","text":"hxpatch!(el::HTMLElement, url::AbstractString) -> HTMLElement\n\nAdd an hx-patch attribute to an HTMLElement in place and return the modified element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxpost!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxpost!","text":"hxpost!(el::HTMLElement, url::AbstractString) -> HTMLElement\n\nAdd an hx-post attribute to an HTMLElement in place and return the modified element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxpreserve!-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.hxpreserve!","text":"hxpreserve!(el::HTMLElement) -> HTMLElement\n\nAdd an hx-preserve attribute to keep this element unchanged between requests. Useful for elements like video players that should maintain state across swaps.\n\nNote: the element must have a stable id attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxprompt!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxprompt!","text":"hxprompt!(el::HTMLElement, message::AbstractString) -> HTMLElement\n\nAdd an hx-prompt attribute that shows a prompt() dialog before submitting the request. The user's response is included in the request via the HX-Prompt header.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxpushurl!","page":"API Reference","title":"HTMLForge.hxpushurl!","text":"hxpushurl!(el::HTMLElement, value::AbstractString=\"true\") -> HTMLElement\n\nAdd an hx-push-url attribute to push the request URL into the browser location bar, creating a history entry. Pass \"true\", \"false\", or a specific URL.\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxput!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxput!","text":"hxput!(el::HTMLElement, url::AbstractString) -> HTMLElement\n\nAdd an hx-put attribute to an HTMLElement in place and return the modified element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxreplaceurl!","page":"API Reference","title":"HTMLForge.hxreplaceurl!","text":"hxreplaceurl!(el::HTMLElement, value::AbstractString=\"true\") -> HTMLElement\n\nAdd an hx-replace-url attribute to replace the current URL in the browser location bar without creating a new history entry. Pass \"true\", \"false\", or a specific URL.\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxrequest!-Tuple{HTMLElement, Union{AbstractString, Symbol}, AbstractString}","page":"API Reference","title":"HTMLForge.hxrequest!","text":"hxrequest!(el::HTMLElement, method::Symbol, url::AbstractString) -> HTMLElement\n\nAdd an htmx request attribute to an HTMLElement in place and return the modified element.\n\nValid methods are :get, :post, :put, :patch, and :delete.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxrequestconfig!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxrequestconfig!","text":"hxrequestconfig!(el::HTMLElement, value::AbstractString) -> HTMLElement\n\nAdd an hx-request attribute to configure various aspects of the request.\n\nvalue is a JSON-like string, e.g., \"timeout:3000, credentials:true\" or \"noHeaders:true\".\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxselect!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxselect!","text":"hxselect!(el::HTMLElement, selector::AbstractString) -> HTMLElement\n\nAdd an hx-select attribute to select a subset of the response HTML to swap into the target.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxselectoob!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxselectoob!","text":"hxselectoob!(el::HTMLElement, selectors::AbstractString) -> HTMLElement\n\nAdd an hx-select-oob attribute to pick out content for out-of-band swaps.\n\nselectors is a comma-separated list of element IDs (e.g., \"#info-details,#other-elt\").\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxswap!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxswap!","text":"hxswap!(el::HTMLElement, style::AbstractString;\n        transition::Union{Nothing,Bool}=nothing,\n        swap::Union{Nothing,AbstractString}=nothing,\n        settle::Union{Nothing,AbstractString}=nothing,\n        ignoreTitle::Union{Nothing,Bool}=nothing,\n        scroll::Union{Nothing,AbstractString}=nothing,\n        show::Union{Nothing,AbstractString}=nothing,\n        focusScroll::Union{Nothing,Bool}=nothing) -> HTMLElement\n\nAdd an hx-swap attribute to an HTMLElement with optional modifiers.\n\nArguments\n\nstyle: The swap style — one of \"innerHTML\" (default), \"outerHTML\", \"afterbegin\", \"beforebegin\", \"beforeend\", \"afterend\", \"delete\", \"none\".\ntransition: Whether to use the View Transition API for this swap.\nswap: A swap delay (e.g. \"100ms\") between clearing old content and inserting new.\nsettle: A settle delay (e.g. \"100ms\") between inserting new content and settling it.\nignoreTitle: If true, any <title> found in new content will be ignored.\nscroll: \"top\" or \"bottom\" — scroll the target element to its top or bottom.\nshow: \"top\" or \"bottom\" — scroll the target element's top or bottom into view.\nfocusScroll: Whether the focused element should be scrolled into view.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxswapoob!","page":"API Reference","title":"HTMLForge.hxswapoob!","text":"hxswapoob!(el::HTMLElement, value::AbstractString=\"true\") -> HTMLElement\n\nAdd an hx-swap-oob attribute to mark an element for out-of-band swapping.\n\nThe value can be \"true\" or any valid swap style optionally followed by a CSS selector (e.g., \"innerHTML:#target\").\n\n\n\n\n\n","category":"function"},{"location":"api/#HTMLForge.hxsync!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxsync!","text":"hxsync!(el::HTMLElement, value::AbstractString) -> HTMLElement\n\nAdd an hx-sync attribute to control how requests made by different elements are synchronized.\n\nCommon values: \"closest form:abort\", \"this:drop\", \"this:queue first\", \"this:queue last\", \"this:queue all\", \"this:replace\".\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxtarget!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxtarget!","text":"hxtarget!(el::HTMLElement, selector::AbstractString) -> HTMLElement\n\nAdd an hx-target attribute to an HTMLElement.\n\nSupported values include standard CSS selectors as well as htmx extended selectors: \"this\", \"closest <selector>\", \"find <selector>\", \"next <selector>\", \"previous <selector>\".\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxtrigger!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxtrigger!","text":"hxtrigger!(el::HTMLElement, event::AbstractString; kwargs...) -> HTMLElement\n\nAdd an hx-trigger attribute to an HTMLElement with appropriate modifiers and return the modified element.\n\nArguments\n\nel: The HTML element to add the trigger to\nevent: The event name (e.g., \"click\", \"mouseenter\", \"load\", \"revealed\")\nonce::Bool: Whether the trigger should only fire once\nchanged::Bool: Whether the trigger should only fire if the value of the element has changed\ndelay::AbstractString: A time interval (e.g., \"1s\") to wait before issuing the request\nthrottle::AbstractString: A time interval (e.g., \"1s\") to throttle requests\nfrom::AbstractString: A CSS selector to listen for the event on a different element\ntarget::AbstractString: A CSS selector to filter the trigger to elements matching the selector\nconsume::Bool: Whether the event should be consumed (not propagated to parent elements)\nqueue::AbstractString: Queue strategy when a request is in flight (\"first\", \"last\", \"all\", \"none\")\nfilter::AbstractString: A JavaScript expression to filter when the trigger fires (without brackets)\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxvalidate!-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.hxvalidate!","text":"hxvalidate!(el::HTMLElement) -> HTMLElement\n\nAdd an hx-validate attribute to force elements to validate themselves before a request. This integrates with the HTML5 Validation API.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.hxvals!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.hxvals!","text":"hxvals!(el::HTMLElement, json::AbstractString) -> HTMLElement\n\nAdd an hx-vals attribute to include additional values with the request.\n\njson should be a JSON-formatted string of name-value pairs, e.g., \"{\"myVal\": \"My Value\"}\".\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.intersect_trigger-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.intersect_trigger","text":"intersect_trigger(el::HTMLElement; \n                 root::Union{Nothing,AbstractString}=nothing,\n                 threshold::Union{Nothing,Real}=nothing,\n                 once::Bool=true) -> HTMLElement\n\nAdd an 'intersect' trigger to an element (fires when element intersects the viewport).\n\nArguments\n\nroot: A CSS selector of the root element for intersection\nthreshold: A floating point between 0.0 and 1.0 indicating the amount of intersection needed\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.load_trigger-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.load_trigger","text":"load_trigger(el::HTMLElement; delay::Union{Nothing,AbstractString}=nothing) -> HTMLElement\n\nAdd a 'load' trigger to an element, optionally with a delay.\n\nExamples\n\n# Trigger on load\nload_trigger(el)\n\n# Trigger on load with delay\nload_trigger(el; delay=\"1s\")\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.parsehtml_snippet-Tuple{AbstractString}","page":"API Reference","title":"HTMLForge.parsehtml_snippet","text":"parsehtml_snippet(input::AbstractString; preserve_whitespace=false, preserve_template=false)\n\nParse an HTML snippet into an HTMLElement. This is useful for parsing a snippet of HTML that is not a complete document, such as a <div> tag.\n\nNote: this function is not as robust as parsehtml and may not work for all inputs. Also, the assumption is that the tag is intended to part of the <body> tag.\n\nFor scenarios where the snippet is composed from multiple sequential tags, the output will be wrapped in a <div> tag.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.poll_trigger-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.poll_trigger","text":"poll_trigger(el::HTMLElement, interval::AbstractString) -> HTMLElement\n\nAdd a polling trigger to an element.\n\nArguments\n\ninterval: The polling interval (e.g., \"2s\", \"500ms\")\n\nExamples\n\n# Poll every 2 seconds\npoll_trigger(el, \"2s\")\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.postorder-Tuple{Any}","page":"API Reference","title":"HTMLForge.postorder","text":"postorder(node)\n\nReturn a post-order depth-first iterator over the tree rooted at node.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.preorder-Tuple{Any}","page":"API Reference","title":"HTMLForge.preorder","text":"preorder(node)\n\nReturn a pre-order depth-first iterator over the tree rooted at node.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.removeclass!-Tuple{HTMLElement, AbstractString}","page":"API Reference","title":"HTMLForge.removeclass!","text":"removeclass!(elem::HTMLElement, cls::AbstractString)\n\nRemoves the class cls from elem.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.revealed_trigger-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.revealed_trigger","text":"revealed_trigger(el::HTMLElement; once::Bool=true) -> HTMLElement\n\nAdd a 'revealed' trigger to an element (fires when element scrolls into view). By default, this only triggers once.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.setattr!-Tuple{HTMLElement, Union{AbstractString, Symbol}, AbstractString}","page":"API Reference","title":"HTMLForge.setattr!","text":"setattrs!(elem::HTMLElement, name::AbstractString, value::AbstractString)\n\nSet the attributes of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.tag-Union{Tuple{HTMLElement{T}}, Tuple{T}} where T","page":"API Reference","title":"HTMLForge.tag","text":"tag(elem::HTMLElement)\n\nGet the tag of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.text-Tuple{HTMLElement}","page":"API Reference","title":"HTMLForge.text","text":"text(el::HTMLElement) :: AbstractString\n\nGet the text of an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.text-Tuple{HTMLText}","page":"API Reference","title":"HTMLForge.text","text":"text(t::HTMLText) :: AbstractString\n\nGet the text of a text element.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.validate-Tuple{Val{:attr}, AbstractString}","page":"API Reference","title":"HTMLForge.validate","text":"validate(::Val{:attr}, value::AbstractString)\n\nValidate HTML attribute names.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.validate-Tuple{Val{:attr}, Vector{<:AbstractString}}","page":"API Reference","title":"HTMLForge.validate","text":"validate(::Val{:attr}, value::AbstractString)\n\nValidate HTML attribute names.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.validate-Tuple{Val{:class}, AbstractString}","page":"API Reference","title":"HTMLForge.validate","text":"validate(::Val{:class}, value::AbstractString)\n\nValidate CSS class names.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.validate-Tuple{Val{:class}, Vector{<:AbstractString}}","page":"API Reference","title":"HTMLForge.validate","text":"validate(::Val{:class}, values::Vector{<:AbstractString})\n\nValidate CSS class names.\n\n\n\n\n\n","category":"method"},{"location":"api/#HTMLForge.@validate-Tuple{Any, Any}","page":"API Reference","title":"HTMLForge.@validate","text":"@validate type value\n\nValidate HTML elements based on their type using compile-time dispatch.\n\nArguments\n\ntype: Symbol indicating what to validate (:attr for attribute names, :class for class names)\nvalue: The string(s) value to validate\n\nExamples\n\n@validate :attr \"class\"  # Validates an attribute name\n@validate :attr [\"id\", \"data-value\"]  # Validates multiple attribute names\n@validate :class \"my-class\"  # Validates a class name\n@validate :class [\"class1\", \"class2\"]  # Validates multiple class names\n\nReturns\n\nReturns true if validation passes, otherwise throws an error.\n\n\n\n\n\n","category":"macro"},{"location":"experimental/#Experimental-HTMX","page":"Experimental HTMX","title":"Experimental HTMX","text":"warning: Experimental\nThis module uses advanced Julia metaprogramming (macros, @eval code generation, Base.getproperty overloading) to compress the full 625-line HTMX API into under 100 lines of code. The interfaces are experimental and may evolve.\n\nThe Experimental module provides three interfaces for working with HTMX attributes. All three can produce identical results — choose the style that fits your workflow.\n\nnote: Note\nThe @hx macro sets raw string values for all attributes. Trigger modifiers like once, delay, etc. must be included directly in the string (e.g., trigger=\"click once\") rather than via keyword arguments.","category":"section"},{"location":"experimental/#Setup","page":"Experimental HTMX","title":"Setup","text":"The experimental module is included separately from the main HTMX API:\n\nusing HTMLForge\ninclude(joinpath(pkgdir(HTMLForge), \"src\", \"Experimental.jl\"))","category":"section"},{"location":"experimental/#Interface-1:-Classic-Functions","page":"Experimental HTMX","title":"Interface 1: Classic Functions","text":"All hx*! functions from the standard API are auto-generated via @eval loop over an attribute registry. They work identically to the standard API:\n\nel = HTMLElement(:button)\nhxget!(el, \"/api/data\")\nhxpost!(el, \"/submit\")\nhxtarget!(el, \"#result\")\nhxswap!(el, \"outerHTML\"; transition=true, settle=\"100ms\")\nhxtrigger!(el, \"click\"; once=true, delay=\"500ms\")\nhxconfirm!(el, \"Are you sure?\")\n\nFlag attributes (no value needed):\n\nhxdisable!(el)     # data-hx-disable=\"\"\nhxpreserve!(el)    # data-hx-preserve=\"\"\nhxvalidate!(el)    # data-hx-validate=\"\"","category":"section"},{"location":"experimental/#How-it-works","page":"Experimental HTMX","title":"How it works","text":"A registry Dict{Symbol, Tuple{String, Symbol}} maps attribute names to their htmx suffix and kind (:v for value-taking, :f for flag). A single for loop with @eval generates all 30+ functions at compile time:\n\nfor (name, (attr, kind)) in _R\n    fn, full = Symbol(:hx, name, :!), \"data-hx-\" * attr\n    if kind == :v\n        @eval \\$fn(el::HTMLElement, v::AbstractString) = (el[\\$full] = v; el)\n    else\n        @eval \\$fn(el::HTMLElement) = (el[\\$full] = \"\"; el)\n    end\nend","category":"section"},{"location":"experimental/#Interface-2:-@hx-Macro","page":"Experimental HTMX","title":"Interface 2: @hx Macro","text":"The @hx macro enables declarative, multi-attribute assignment in a single expression.","category":"section"},{"location":"experimental/#Creating-a-new-element","page":"Experimental HTMX","title":"Creating a new element","text":"Pass a symbol to simultaneously create an element and set attributes:\n\nbtn = @hx :button get=\"/api\" trigger=\"click\" target=\"#result\"\n# Equivalent to:\n#   btn = HTMLElement(:button)\n#   btn[\"data-hx-get\"] = \"/api\"\n#   btn[\"data-hx-trigger\"] = \"click\"\n#   btn[\"data-hx-target\"] = \"#result\"","category":"section"},{"location":"experimental/#Modifying-an-existing-element","page":"Experimental HTMX","title":"Modifying an existing element","text":"Pass a variable to modify it in place:\n\nel = HTMLElement(:form)\n@hx el post=\"/submit\" swap=\"outerHTML\" confirm=\"Sure?\"","category":"section"},{"location":"experimental/#Underscores-become-hyphens","page":"Experimental HTMX","title":"Underscores become hyphens","text":"Use underscores in attribute names — they are automatically converted to hyphens:\n\n@hx el push_url=\"true\" replace_url=\"/new\"\n# → data-hx-push-url=\"true\", data-hx-replace-url=\"/new\"","category":"section"},{"location":"experimental/#Expression-interpolation","page":"Experimental HTMX","title":"Expression interpolation","text":"Values can be any Julia expression:\n\nurl = \"/api/v2/items\"\nbtn = @hx :button get=url","category":"section"},{"location":"experimental/#How-it-works-2","page":"Experimental HTMX","title":"How it works","text":"The macro inspects its first argument at compile time:\n\nQuoteNode (e.g. :button) → generates HTMLElement(:button)\nanything else → esc(el) to use the existing variable\n\nIt then iterates over the key=value pairs, converting them to el[\"data-hx-key\"] = string(value) assignments. The entire expansion is a begin...end block returning the element.","category":"section"},{"location":"experimental/#Interface-3:-hx.*-Pipe-DSL","page":"Experimental HTMX","title":"Interface 3: hx.* Pipe DSL","text":"The most ergonomic interface — chain htmx attributes with Julia's |> operator using the hx singleton:\n\nel = HTMLElement(:button) |>\n    hx.post(\"/api/submit\") |>\n    hx.trigger(\"click\"; once=true) |>\n    hx.target(\"#response\") |>\n    hx.swap(\"outerHTML\"; transition=true, settle=\"200ms\") |>\n    hx.confirm(\"Proceed?\") |>\n    hx.indicator(\"#spinner\")","category":"section"},{"location":"experimental/#Value-attributes","page":"Experimental HTMX","title":"Value attributes","text":"Every registered attribute is accessible as hx.<name>(value):\n\nel |> hx.get(\"/api\")\nel |> hx.target(\"#out\")\nel |> hx.boost(\"true\")\nel |> hx.pushurl(\"true\")\nel |> hx.headers(\"{\\\"X-Token\\\": \\\"abc\\\"}\")","category":"section"},{"location":"experimental/#Flag-attributes","page":"Experimental HTMX","title":"Flag attributes","text":"Flag attributes take no arguments:\n\nel |> hx.disable()\nel |> hx.preserve()\nel |> hx.validate()","category":"section"},{"location":"experimental/#Complex-attributes","page":"Experimental HTMX","title":"Complex attributes","text":"hx.trigger, hx.swap, and hx.on support the same keyword arguments as their function counterparts:\n\nel |> hx.trigger(\"keyup\"; delay=\"300ms\", changed=true)\nel |> hx.swap(\"innerHTML\"; transition=true, focusScroll=false)\nel |> hx.on(\"click\", \"console.log('clicked')\")","category":"section"},{"location":"experimental/#How-it-works-3","page":"Experimental HTMX","title":"How it works","text":"hx is a zero-size singleton struct _HxPipe. A Base.getproperty override intercepts hx.foo and returns a curried closure: calling hx.get(\"/api\") returns el -> (el[\"data-hx-get\"] = \"/api\"; el), which is exactly the signature |> expects. For trigger and swap, the closures forward keyword arguments to the full hxtrigger! / hxswap! implementations.","category":"section"},{"location":"experimental/#Complete-Comparison","page":"Experimental HTMX","title":"Complete Comparison","text":"Here's the same element built with all three interfaces:\n\n# Classic\nel = HTMLElement(:button)\nhxpost!(el, \"/submit\")\nhxtarget!(el, \"#result\")\nhxswap!(el, \"outerHTML\")\nhxtrigger!(el, \"click\"; once=true)\nhxconfirm!(el, \"Sure?\")\n\n# @hx macro — trigger modifiers are included in the raw string\nel = @hx :button post=\"/submit\" target=\"#result\" swap=\"outerHTML\" trigger=\"click once\" confirm=\"Sure?\"\n\n# Pipe DSL\nel = HTMLElement(:button) |>\n    hx.post(\"/submit\") |>\n    hx.target(\"#result\") |>\n    hx.swap(\"outerHTML\") |>\n    hx.trigger(\"click\"; once=true) |>\n    hx.confirm(\"Sure?\")\n\ntip: Tip\nThe Classic and Pipe interfaces build trigger/swap modifiers via keyword arguments. The @hx macro sets all values as raw strings — include the full hx-trigger or hx-swap value directly (e.g., trigger=\"click once delay:500ms\").","category":"section"},{"location":"experimental/#Supported-Attributes","page":"Experimental HTMX","title":"Supported Attributes","text":"","category":"section"},{"location":"experimental/#Value-Attributes-(take-a-string-argument)","page":"Experimental HTMX","title":"Value Attributes (take a string argument)","text":"Function htmx attribute Pipe\nhxget! data-hx-get hx.get(url)\nhxpost! data-hx-post hx.post(url)\nhxput! data-hx-put hx.put(url)\nhxpatch! data-hx-patch hx.patch(url)\nhxdelete! data-hx-delete hx.delete(url)\nhxtarget! data-hx-target hx.target(sel)\nhxselect! data-hx-select hx.select(sel)\nhxswapoob! data-hx-swap-oob hx.swapoob(v)\nhxselectoob! data-hx-select-oob hx.selectoob(v)\nhxvals! data-hx-vals hx.vals(json)\nhxpushurl! data-hx-push-url hx.pushurl(v)\nhxreplaceurl! data-hx-replace-url hx.replaceurl(v)\nhxconfirm! data-hx-confirm hx.confirm(msg)\nhxprompt! data-hx-prompt hx.prompt(msg)\nhxindicator! data-hx-indicator hx.indicator(sel)\nhxboost! data-hx-boost hx.boost(v)\nhxinclude! data-hx-include hx.include(sel)\nhxparams! data-hx-params hx.params(v)\nhxheaders! data-hx-headers hx.headers(json)\nhxsync! data-hx-sync hx.sync(v)\nhxencoding! data-hx-encoding hx.encoding(v)\nhxext! data-hx-ext hx.ext(v)\nhxdisinherit! data-hx-disinherit hx.disinherit(v)\nhxinherit! data-hx-inherit hx.inherit(v)\nhxhistory! data-hx-history hx.history(v)\nhxrequest! (config) data-hx-request hx.request(v)\nhxdisabledelt! data-hx-disabled-elt hx.disabledelt(sel)","category":"section"},{"location":"experimental/#Flag-Attributes-(no-argument)","page":"Experimental HTMX","title":"Flag Attributes (no argument)","text":"Function htmx attribute Pipe\nhxdisable! data-hx-disable hx.disable()\nhxpreserve! data-hx-preserve hx.preserve()\nhxvalidate! data-hx-validate hx.validate()\nhxhistoryelt! data-hx-history-elt hx.historyelt()","category":"section"},{"location":"experimental/#Complex-Attributes-(with-keyword-arguments)","page":"Experimental HTMX","title":"Complex Attributes (with keyword arguments)","text":"Function Pipe Supports kwargs\nhxtrigger!(el, event; ...) hx.trigger(event; ...) once, changed, delay, throttle, from, target, consume, queue, filter\nhxswap!(el, style; ...) hx.swap(style; ...) transition, swap, settle, ignoreTitle, scroll, show, focusScroll\nhxon!(el, event, script) hx.on(event, script) —","category":"section"},{"location":"experimental/#Metaprogramming-Techniques-Used","page":"Experimental HTMX","title":"Metaprogramming Techniques Used","text":"Technique Where Purpose\n@eval in a loop Function generation Generate 30+ hx*! functions from a registry Dict\nSymbol arithmetic Symbol(:hx, name, :!) Dynamic function naming\nmacro with AST introspection @hx Detect QuoteNode vs variable to choose creation vs modification\nBase.getproperty overloading hx.* pipe DSL Create a callable namespace on a zero-size singleton\nCurried closures Pipe DSL Return el -> ... functions compatible with |>","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(\"HTMLForge\")\n\nOr activate Pkg mode in the REPL by typing ]:\n\nadd HTMLForge","category":"section"},{"location":"getting_started/#Parsing-your-first-document","page":"Getting Started","title":"Parsing your first document","text":"using HTMLForge\n\ndoc = parsehtml(\"<h1> Hello, world! </h1>\")\n\nThis returns an HTMLDocument with a doctype field and a root field pointing to the root HTMLElement.","category":"section"},{"location":"getting_started/#Parsing-a-file","page":"Getting Started","title":"Parsing a file","text":"doc = parsehtml(read(\"myfile.html\", String))","category":"section"},{"location":"getting_started/#Parsing-a-snippet","page":"Getting Started","title":"Parsing a snippet","text":"Use parsehtml_snippet for HTML fragments (not full documents):\n\nel = parsehtml_snippet(\"<p>Hello</p>\")\n\nIf the snippet has multiple top-level tags, they are automatically wrapped in a <div>.","category":"section"},{"location":"getting_started/#Creating-elements-from-scratch","page":"Getting Started","title":"Creating elements from scratch","text":"el = HTMLElement(:div)\nel[\"class\"] = \"container\"\n\nchild = HTMLElement(:p, HTMLText(\"Hello!\"))\npush!(el, child)\n\nprettyprint(el)","category":"section"},{"location":"getting_started/#Adding-HTMX-attributes","page":"Getting Started","title":"Adding HTMX attributes","text":"All HTMX helpers mutate in place and return the element for chaining:\n\nbtn = HTMLElement(:button)\nhxpost!(btn, \"/api/submit\")\nhxtarget!(btn, \"#result\")\nhxswap!(btn, \"outerHTML\")\n\nSee the HTMX Support and Experimental HTMX sections for the full API.","category":"section"},{"location":"llm/#HTMLForge.jl-—-LLM-Reference","page":"LLM Reference","title":"HTMLForge.jl — LLM Reference","text":"This page is a condensed, single-file reference for HTMLForge.jl (v0.3.13) optimized for LLM code-generation systems. It covers the full public API. Julia ≥ 1.8.","category":"section"},{"location":"llm/#Install","page":"LLM Reference","title":"Install","text":"using Pkg; Pkg.add(\"HTMLForge\")\nusing HTMLForge\n\n","category":"section"},{"location":"llm/#Type-Hierarchy","page":"LLM Reference","title":"Type Hierarchy","text":"HTMLNode (abstract)\n├── HTMLElement{T}   # T is a Symbol tag, e.g. HTMLElement{:div}\n├── HTMLText         # text node\n└── NullNode         # sentinel for missing parents","category":"section"},{"location":"llm/#HTMLDocument","page":"LLM Reference","title":"HTMLDocument","text":"Returned by parsehtml. Fields:\n\ndoctype::AbstractString — doctype string (empty if none)\nroot::HTMLElement — root of the document tree","category":"section"},{"location":"llm/#HTMLElement{T}","page":"LLM Reference","title":"HTMLElement{T}","text":"mutable struct HTMLElement{T} <: HTMLNode\n    children::Vector{HTMLNode}\n    parent::HTMLNode\n    attributes::Dict{AbstractString, AbstractString}\nend\n\nConstructors:\n\nHTMLElement(:div)                                          # empty\nHTMLElement(:div, HTMLText(\"hello\"))                        # single child\nHTMLElement(:p, [HTMLText(\"text\")], Dict(\"class\"=>\"intro\")) # children + attrs\nHTMLElement(:div, HTMLNode[]; data_id=\"42\", class=\"box\")   # keyword attrs (underscores → hyphens)\n\nIndexing:\n\nel[\"class\"] = \"wide\"   # set attribute\nel[:class]             # get attribute → \"wide\"\nel[1]                  # first child","category":"section"},{"location":"llm/#HTMLText","page":"LLM Reference","title":"HTMLText","text":"HTMLText(\"some text\")  # parent defaults to NullNode()\n\n","category":"section"},{"location":"llm/#Parsing","page":"LLM Reference","title":"Parsing","text":"","category":"section"},{"location":"llm/#parsehtml","page":"LLM Reference","title":"parsehtml","text":"parsehtml(html::String;\n    strict=false,              # throw InvalidHTMLException on errors\n    preserve_whitespace=false, # keep whitespace text nodes\n    preserve_template=false,   # preserve <template> elements\n    include_parent=true        # set parent references\n) → HTMLDocument","category":"section"},{"location":"llm/#parsehtml_snippet","page":"LLM Reference","title":"parsehtml_snippet","text":"parsehtml_snippet(html::String;\n    preserve_whitespace=false,\n    preserve_template=false\n) → HTMLElement\n\nReturns an HTMLElement. Multiple top-level tags are wrapped in a <div>.\n\n","category":"section"},{"location":"llm/#Manipulation","page":"LLM Reference","title":"Manipulation","text":"","category":"section"},{"location":"llm/#Element-properties","page":"LLM Reference","title":"Element properties","text":"tag(el)                    # → Symbol (:div, :p, etc.)\nattrs(el)                  # → Dict of attributes\ngetattr(el, name)          # → value or nothing\ngetattr(el, name, default) # → value or default\nsetattr!(el, name, value)  # set attribute (validated)\nhasattr(el, name)          # → Bool\nchildren(el)               # → Vector{HTMLNode}\ntext(el)                   # recursively extract all text","category":"section"},{"location":"llm/#Finding-elements","page":"LLM Reference","title":"Finding elements","text":"findfirst(f, el)           # first descendant matching predicate f (pre-order DFS)\nfindfirst(f, doc)          # same, starting from doc\ngetbyid(el_or_doc, id)    # find element by id attribute\napplyif!(cond, f!, el_or_doc) # apply mutating f! to all elements matching cond","category":"section"},{"location":"llm/#CSS-class-helpers","page":"LLM Reference","title":"CSS class helpers","text":"hasclass(el, cls)          # → Bool\naddclass!(el, cls)         # add class (no-op if present)\nremoveclass!(el, cls)      # remove class\nreplaceclass!(el, old, new) # replace; pass nothing to just remove","category":"section"},{"location":"llm/#Validation","page":"LLM Reference","title":"Validation","text":"@validate :attr \"data-value\"          # validate attribute name\n@validate :class \"my-class\"           # validate class name\n@validate :attr [\"a\", \"b\"]           # validate multiple attribute names\n@validate :class [\"c1\", \"c2\"]        # validate multiple class names\n\nInvalid names raise InvalidAttributeException. Invalid class values raise ArgumentError or InvalidAttributeException.","category":"section"},{"location":"llm/#Pretty-printing","page":"LLM Reference","title":"Pretty printing","text":"prettyprint(el)            # print to stdout\nprettyprint(io, el)        # print to IO\nprettyprint(doc)           # works on documents too\n\n","category":"section"},{"location":"llm/#Tree-Traversal","page":"LLM Reference","title":"Tree Traversal","text":"Re-exported from AbstractTrees.jl:\n\npreorder(node)             # pre-order DFS\npostorder(node)            # post-order DFS\nbreadthfirst(node)         # breadth-first (level-order)\n\nUse with for elem in preorder(doc.root) ... end.\n\n","category":"section"},{"location":"llm/#Equality","page":"LLM Reference","title":"Equality","text":"HTMLDocument, HTMLElement, and HTMLText support ==, isequal, hash. Elements are equal when they have the same tag, attributes, and children (parents are ignored).\n\n","category":"section"},{"location":"llm/#HTMX-Support","page":"LLM Reference","title":"HTMX Support","text":"All HTMX helpers mutate in place and return the element (enabling chaining). Attributes are stored with the data-hx- prefix.","category":"section"},{"location":"llm/#Generic-setter","page":"LLM Reference","title":"Generic setter","text":"hxattr!(el, attr, value)   # data-hx-<attr>=\"value\"","category":"section"},{"location":"llm/#AJAX-request-helpers","page":"LLM Reference","title":"AJAX request helpers","text":"hxget!(el, url)            # data-hx-get\nhxpost!(el, url)           # data-hx-post\nhxput!(el, url)            # data-hx-put\nhxpatch!(el, url)          # data-hx-patch\nhxdelete!(el, url)         # data-hx-delete\nhxrequest!(el, method, url) # data-hx-<method>","category":"section"},{"location":"llm/#Trigger","page":"LLM Reference","title":"Trigger","text":"hxtrigger!(el, event;\n    once=false, changed=false, delay=nothing, throttle=nothing,\n    from=nothing, target=nothing, consume=false, queue=nothing,\n    filter=nothing\n)\n# Example: hxtrigger!(el, \"click\"; once=true, delay=\"500ms\")\n# → data-hx-trigger=\"click once delay:500ms\"\n# Filter: hxtrigger!(el, \"click\"; filter=\"ctrlKey\")\n# → data-hx-trigger=\"click[ctrlKey]\"","category":"section"},{"location":"llm/#Target-and-swap","page":"LLM Reference","title":"Target & swap","text":"hxtarget!(el, selector)    # CSS selector, \"this\", \"closest ...\", etc.\n\nhxswap!(el, style;\n    transition=nothing, swap=nothing, settle=nothing,\n    ignoreTitle=nothing, scroll=nothing, show=nothing,\n    focusScroll=nothing\n)\n# Valid styles: \"innerHTML\", \"outerHTML\", \"afterbegin\", \"beforebegin\",\n#               \"beforeend\", \"afterend\", \"delete\", \"none\"\n# Example: hxswap!(el, \"innerHTML\"; transition=true, settle=\"100ms\")\n\nhxswapoob!(el, value)     # out-of-band swap\nhxselect!(el, selector)   # select subset of response\nhxselectoob!(el, sels)    # out-of-band select","category":"section"},{"location":"llm/#Values-and-URLs","page":"LLM Reference","title":"Values & URLs","text":"hxvals!(el, json)          # additional values (JSON string)\nhxpushurl!(el, value)      # push URL (\"true\", \"false\", or URL)\nhxreplaceurl!(el, value)   # replace URL without history entry","category":"section"},{"location":"llm/#User-interaction","page":"LLM Reference","title":"User interaction","text":"hxconfirm!(el, message)    # confirm() dialog\nhxprompt!(el, message)     # prompt() dialog\nhxindicator!(el, selector) # element to show during request","category":"section"},{"location":"llm/#Progressive-enhancement-and-parameters","page":"LLM Reference","title":"Progressive enhancement & parameters","text":"hxboost!(el, value)        # \"true\"/\"false\"\nhxinclude!(el, selector)   # include other elements' values\nhxparams!(el, value)       # \"*\", \"none\", specific list, \"not ...\"\nhxheaders!(el, json)       # additional headers (JSON)\nhxsync!(el, value)         # e.g. \"closest form:abort\"\nhxencoding!(el, encoding)  # e.g. \"multipart/form-data\"\nhxext!(el, extensions)     # comma-separated extension list","category":"section"},{"location":"llm/#Event-handling","page":"LLM Reference","title":"Event handling","text":"hxon!(el, event, script)   # data-hx-on:<event>=\"script\"","category":"section"},{"location":"llm/#Disable-and-inheritance","page":"LLM Reference","title":"Disable & inheritance","text":"hxdisable!(el)             # disable htmx on element+children\nhxdisabledelt!(el, sel)    # disable elements during request\nhxdisinherit!(el, attrs)   # disable inheritance (\"*\" or space-separated)\nhxinherit!(el, attrs)      # enable inheritance","category":"section"},{"location":"llm/#History-and-preservation","page":"LLM Reference","title":"History & preservation","text":"hxhistory!(el, value)      # \"false\" to prevent caching\nhxhistoryelt!(el)          # mark as history snapshot source\nhxpreserve!(el)            # keep unchanged between requests (needs stable id)","category":"section"},{"location":"llm/#Request-config-and-validation","page":"LLM Reference","title":"Request config & validation","text":"hxrequestconfig!(el, val)  # e.g. \"timeout:3000, credentials:true\"\nhxvalidate!(el)            # enable HTML5 validation before request","category":"section"},{"location":"llm/#Chaining","page":"LLM Reference","title":"Chaining","text":"el = HTMLElement(:button)\nel |> x -> hxpost!(x, \"/submit\") |>\n     x -> hxtarget!(x, \"#result\") |>\n     x -> hxswap!(x, \"outerHTML\") |>\n     x -> hxconfirm!(x, \"Sure?\")\n\n","category":"section"},{"location":"llm/#Experimental-HTMX-Module","page":"LLM Reference","title":"Experimental HTMX Module","text":"Three additional interfaces. Load with:\n\nusing HTMLForge\ninclude(joinpath(pkgdir(HTMLForge), \"src\", \"Experimental.jl\"))","category":"section"},{"location":"llm/#Interface-1:-Classic-functions-(auto-generated)","page":"LLM Reference","title":"Interface 1: Classic functions (auto-generated)","text":"Same as standard API above — all hx*! functions are generated via @eval from an internal registry.","category":"section"},{"location":"llm/#Interface-2:-@hx-macro","page":"LLM Reference","title":"Interface 2: @hx macro","text":"Declarative multi-attribute assignment:\n\n# Create + assign\nbtn = @hx :button get=\"/api\" trigger=\"click\" target=\"#result\"\n\n# Modify existing\nel = HTMLElement(:form)\n@hx el post=\"/submit\" swap=\"outerHTML\" confirm=\"Sure?\"\n\n# Underscores → hyphens\n@hx el push_url=\"true\" replace_url=\"/new\"\n\n# Expression interpolation\nurl = \"/api/v2\"\nbtn = @hx :button get=url\n\nNote: @hx sets raw string values. Trigger modifiers must be in the string: trigger=\"click once delay:500ms\".","category":"section"},{"location":"llm/#Interface-3:-hx.*-pipe-DSL","page":"LLM Reference","title":"Interface 3: hx.* pipe DSL","text":"Most ergonomic — uses |> with curried closures:\n\nel = HTMLElement(:button) |>\n    hx.post(\"/api/submit\") |>\n    hx.trigger(\"click\"; once=true) |>\n    hx.target(\"#response\") |>\n    hx.swap(\"outerHTML\"; transition=true, settle=\"200ms\") |>\n    hx.confirm(\"Proceed?\") |>\n    hx.indicator(\"#spinner\")\n\nFlag attributes: hx.disable(), hx.preserve(), hx.validate(), hx.historyelt().","category":"section"},{"location":"llm/#Side-by-side-comparison","page":"LLM Reference","title":"Side-by-side comparison","text":"# Classic\nel = HTMLElement(:button)\nhxpost!(el, \"/submit\")\nhxtarget!(el, \"#result\")\nhxswap!(el, \"outerHTML\")\nhxtrigger!(el, \"click\"; once=true)\nhxconfirm!(el, \"Sure?\")\n\n# @hx macro\nel = @hx :button post=\"/submit\" target=\"#result\" swap=\"outerHTML\" trigger=\"click once\" confirm=\"Sure?\"\n\n# Pipe DSL\nel = HTMLElement(:button) |>\n    hx.post(\"/submit\") |>\n    hx.target(\"#result\") |>\n    hx.swap(\"outerHTML\") |>\n    hx.trigger(\"click\"; once=true) |>\n    hx.confirm(\"Sure?\")\n\n","category":"section"},{"location":"llm/#Complete-HTMX-Attribute-Table","page":"LLM Reference","title":"Complete HTMX Attribute Table","text":"","category":"section"},{"location":"llm/#Value-attributes","page":"LLM Reference","title":"Value attributes","text":"Function Attribute Pipe\nhxget!(el, v) data-hx-get hx.get(v)\nhxpost!(el, v) data-hx-post hx.post(v)\nhxput!(el, v) data-hx-put hx.put(v)\nhxpatch!(el, v) data-hx-patch hx.patch(v)\nhxdelete!(el, v) data-hx-delete hx.delete(v)\nhxtarget!(el, v) data-hx-target hx.target(v)\nhxselect!(el, v) data-hx-select hx.select(v)\nhxswapoob!(el, v) data-hx-swap-oob hx.swapoob(v)\nhxselectoob!(el, v) data-hx-select-oob hx.selectoob(v)\nhxvals!(el, v) data-hx-vals hx.vals(v)\nhxpushurl!(el, v) data-hx-push-url hx.pushurl(v)\nhxreplaceurl!(el, v) data-hx-replace-url hx.replaceurl(v)\nhxconfirm!(el, v) data-hx-confirm hx.confirm(v)\nhxprompt!(el, v) data-hx-prompt hx.prompt(v)\nhxindicator!(el, v) data-hx-indicator hx.indicator(v)\nhxboost!(el, v) data-hx-boost hx.boost(v)\nhxinclude!(el, v) data-hx-include hx.include(v)\nhxparams!(el, v) data-hx-params hx.params(v)\nhxheaders!(el, v) data-hx-headers hx.headers(v)\nhxsync!(el, v) data-hx-sync hx.sync(v)\nhxencoding!(el, v) data-hx-encoding hx.encoding(v)\nhxext!(el, v) data-hx-ext hx.ext(v)\nhxdisinherit!(el, v) data-hx-disinherit hx.disinherit(v)\nhxinherit!(el, v) data-hx-inherit hx.inherit(v)\nhxhistory!(el, v) data-hx-history hx.history(v)\nhxrequestconfig!(el, v) data-hx-request hx.request(v)\nhxdisabledelt!(el, v) data-hx-disabled-elt hx.disabledelt(v)","category":"section"},{"location":"llm/#Flag-attributes-(no-argument)","page":"LLM Reference","title":"Flag attributes (no argument)","text":"Function Attribute Pipe\nhxdisable!(el) data-hx-disable hx.disable()\nhxpreserve!(el) data-hx-preserve hx.preserve()\nhxvalidate!(el) data-hx-validate hx.validate()\nhxhistoryelt!(el) data-hx-history-elt hx.historyelt()","category":"section"},{"location":"llm/#Complex-attributes-(keyword-arguments)","page":"LLM Reference","title":"Complex attributes (keyword arguments)","text":"Function Pipe kwargs\nhxtrigger!(el, event; ...) hx.trigger(event; ...) once, changed, delay, throttle, from, target, consume, queue, filter\nhxswap!(el, style; ...) hx.swap(style; ...) transition, swap, settle, ignoreTitle, scroll, show, focusScroll\nhxon!(el, event, script) hx.on(event, script) —\n\n","category":"section"},{"location":"llm/#Common-Patterns","page":"LLM Reference","title":"Common Patterns","text":"","category":"section"},{"location":"llm/#Parse-find-modify-print","page":"LLM Reference","title":"Parse → find → modify → print","text":"doc = parsehtml(read(\"page.html\", String))\nel = getbyid(doc, \"main-content\")\naddclass!(el, \"active\")\nhxget!(el, \"/api/refresh\")\nhxtarget!(el, \"#content\")\nprettyprint(doc)","category":"section"},{"location":"llm/#Build-an-element-tree-from-scratch","page":"LLM Reference","title":"Build an element tree from scratch","text":"div = HTMLElement(:div)\ndiv[\"class\"] = \"container\"\n\nheader = HTMLElement(:h1, HTMLText(\"Title\"))\npush!(div, header)\n\nbtn = HTMLElement(:button, HTMLText(\"Click me\"))\nhxpost!(btn, \"/api/action\")\nhxtarget!(btn, \"#result\")\nhxswap!(btn, \"innerHTML\")\npush!(div, btn)\n\nresult = HTMLElement(:div)\nresult[\"id\"] = \"result\"\npush!(div, result)\n\nprettyprint(div)","category":"section"},{"location":"llm/#Traverse-and-transform","page":"LLM Reference","title":"Traverse and transform","text":"doc = parsehtml(html_string)\nfor el in preorder(doc.root)\n    if isa(el, HTMLElement) && tag(el) == :a\n        hxboost!(el, \"true\")\n    end\nend","category":"section"},{"location":"llm/#Apply-a-change-to-all-matching-elements","page":"LLM Reference","title":"Apply a change to all matching elements","text":"applyif!(el -> tag(el) == :form, el -> hxboost!(el, \"true\"), doc)","category":"section"},{"location":"llm/#Experimental-pipe-DSL-full-example","page":"LLM Reference","title":"Experimental pipe DSL full example","text":"using HTMLForge\ninclude(joinpath(pkgdir(HTMLForge), \"src\", \"Experimental.jl\"))\n\nform = HTMLElement(:form) |>\n    hx.post(\"/api/submit\") |>\n    hx.target(\"#result\") |>\n    hx.swap(\"outerHTML\"; transition=true) |>\n    hx.trigger(\"submit\"; once=true) |>\n    hx.confirm(\"Submit form?\") |>\n    hx.indicator(\"#spinner\")","category":"section"},{"location":"manipulation/#Manipulation","page":"Manipulation","title":"Manipulation","text":"","category":"section"},{"location":"manipulation/#Accessing-Element-Properties","page":"Manipulation","title":"Accessing Element Properties","text":"tag(elem) — get the tag of an element as a symbol\nattrs(elem) — return the attributes dict\ngetattr(elem, name[, default]) — get attribute value or nothing/default\nsetattr!(elem, name, value) — set attribute (validated)\nhasattr(elem, name) — check whether an attribute exists","category":"section"},{"location":"manipulation/#Children-and-Text","page":"Manipulation","title":"Children and Text","text":"children(elem) — return the children array\ntext(elem) — recursively extract all text content","category":"section"},{"location":"manipulation/#Finding-Elements","page":"Manipulation","title":"Finding Elements","text":"findfirst(f, elem) / findfirst(f, doc) — find the first element (pre-order DFS) matching predicate f\ngetbyid(elem, id) / getbyid(doc, id) — find element by id attribute\napplyif!(condition, f!, elem) — apply a mutating function to all matching elements","category":"section"},{"location":"manipulation/#Examples","page":"Manipulation","title":"Examples","text":"# Find the first <a> tag\nfindfirst(x -> tag(x) == :a, doc.root)\n\n# Find element by id\ngetbyid(doc, \"main-content\")\n\n# Apply a function to all matching elements\napplyif!(x -> tag(x) == :div, x -> setattr!(x, \"class\", \"wide\"), doc)","category":"section"},{"location":"manipulation/#CSS-Class-Helpers","page":"Manipulation","title":"CSS Class Helpers","text":"hasclass(elem, cls) — check if element has a CSS class\naddclass!(elem, cls) — add a CSS class (no-op if already present)\nremoveclass!(elem, cls) — remove a CSS class\nreplaceclass!(elem, old, new) — replace one class with another; pass nothing to remove","category":"section"},{"location":"manipulation/#Examples-2","page":"Manipulation","title":"Examples","text":"el = HTMLElement(:div)\naddclass!(el, \"active\")\naddclass!(el, \"highlight\")\nhasclass(el, \"active\")       # true\nreplaceclass!(el, \"active\", \"inactive\")\nremoveclass!(el, \"highlight\")","category":"section"},{"location":"manipulation/#Validation","page":"Manipulation","title":"Validation","text":"Attribute names and CSS class values are validated automatically when using setattr!, addclass!, replaceclass!, and bracket assignment.\n\nInvalid attribute names raise InvalidAttributeException. Invalid class values raise ArgumentError or InvalidAttributeException.\n\nUse the @validate macro directly:\n\n@validate :attr \"data-value\"          # validate attribute name\n@validate :class \"my-class\"           # validate class name\n@validate :attr [\"id\", \"data-value\"]  # validate multiple names\n@validate :class [\"cls1\", \"cls2\"]     # validate multiple classes","category":"section"},{"location":"manipulation/#Pretty-Printing","page":"Manipulation","title":"Pretty Printing","text":"prettyprint(elem) / prettyprint(io, elem) — output nicely indented HTML:\n\nprettyprint(doc)              # print document to stdout\nprettyprint(io, doc)          # print to IO stream\nprettyprint(elem)             # print element","category":"section"},{"location":"traversal/#Tree-Traversal","page":"Traversal","title":"Tree Traversal","text":"HTMLForge re-exports convenience aliases for common tree traversal strategies from AbstractTrees.jl.\n\npreorder(node) — pre-order depth-first traversal\npostorder(node) — post-order depth-first traversal\nbreadthfirst(node) — breadth-first (level-order) traversal","category":"section"},{"location":"traversal/#Example","page":"Traversal","title":"Example","text":"using HTMLForge\n\ndoc = parsehtml(\"\"\"\n    <html>\n      <body>\n        <div>\n          <p></p> <a></a> <p></p>\n        </div>\n        <div>\n          <span></span>\n        </div>\n      </body>\n    </html>\n\"\"\")\n\nfor elem in preorder(doc.root)\n    println(tag(elem))\nend\n# HTML, head, body, div, p, a, p, div, span\n\nfor elem in postorder(doc.root)\n    println(tag(elem))\nend\n# head, p, a, p, div, span, div, body, HTML\n\nfor elem in breadthfirst(doc.root)\n    println(tag(elem))\nend\n# HTML, head, body, div, div, p, a, p, span\n\nYou can also use the iterators from AbstractTrees.jl directly (PreOrderDFS, PostOrderDFS, StatelessBFS).","category":"section"},{"location":"traversal/#Comparison-and-Equality","page":"Traversal","title":"Comparison and Equality","text":"HTMLDocument, HTMLElement, and HTMLText all support ==, isequal, and hash. Two elements are considered equal if they have the same tag, attributes, and children (parents are ignored):\n\nHTMLElement(:div) == HTMLElement(:div)  # true","category":"section"},{"location":"htmx/#HTMX-Support","page":"HTMX Support","title":"HTMX Support","text":"HTMLForge treats HTMX as a first-class citizen. All HTMX attribute helpers mutate the element in place and return it, enabling chaining. Attributes are stored with the data-hx- prefix for HTML spec compliance.\n\ntip: Looking for the experimental DSL?\nCheck out the Experimental HTMX page for the macro-powered @hx and pipe hx.* interfaces.","category":"section"},{"location":"htmx/#Generic-Attribute-Setter","page":"HTMX Support","title":"Generic Attribute Setter","text":"hxattr!(el, attr, value) — Set any htmx attribute. The data-hx- prefix is added automatically:\n\nel = HTMLElement(:div)\nhxattr!(el, \"custom\", \"value\")   # → data-hx-custom=\"value\"\nhxattr!(el, :target, \"#result\")  # → data-hx-target=\"#result\"","category":"section"},{"location":"htmx/#AJAX-Request-Helpers","page":"HTMX Support","title":"AJAX Request Helpers","text":"Function htmx attribute\nhxget!(el, url) data-hx-get\nhxpost!(el, url) data-hx-post\nhxput!(el, url) data-hx-put\nhxpatch!(el, url) data-hx-patch\nhxdelete!(el, url) data-hx-delete\nhxrequest!(el, method, url) data-hx-<method>\n\nel = HTMLElement(:button)\nhxget!(el, \"/api/items\")\nhxpost!(el, \"/api/submit\")\nhxrequest!(el, :put, \"/api/update\")","category":"section"},{"location":"htmx/#Trigger","page":"HTMX Support","title":"Trigger","text":"hxtrigger!(el, event; once, changed, delay, throttle, from, target, consume, queue, filter)\n\nBuild complex hx-trigger values with full modifier support:\n\nel = HTMLElement(:div)\nhxtrigger!(el, \"click\"; once=true, delay=\"500ms\")\n# → data-hx-trigger=\"click once delay:500ms\"\n\nhxtrigger!(el, \"keyup\"; changed=true, delay=\"500ms\")\n# → data-hx-trigger=\"keyup changed delay:500ms\"\n\nhxtrigger!(el, \"click\"; filter=\"ctrlKey\")\n# → data-hx-trigger=\"click[ctrlKey]\"","category":"section"},{"location":"htmx/#Target-and-Swap","page":"HTMX Support","title":"Target and Swap","text":"hxtarget!(el, selector) — CSS selector, \"this\", \"closest ...\", etc.\nhxswap!(el, style; ...) — swap style with optional modifiers\nhxswapoob!(el, value) — out-of-band swap\nhxselect!(el, selector) — select subset of response\nhxselectoob!(el, selectors) — out-of-band select\n\nhxswap! supports keyword modifiers: transition, swap, settle, ignoreTitle, scroll, show, focusScroll.\n\nValid swap styles: \"innerHTML\", \"outerHTML\", \"afterbegin\", \"beforebegin\", \"beforeend\", \"afterend\", \"delete\", \"none\".\n\nel = HTMLElement(:div)\nhxswap!(el, \"innerHTML\"; transition=true, settle=\"100ms\")\n# → data-hx-swap=\"innerHTML transition:true settle:100ms\"","category":"section"},{"location":"htmx/#Values-and-URLs","page":"HTMX Support","title":"Values and URLs","text":"hxvals!(el, json) — include additional values (JSON string)\nhxpushurl!(el, value) — push URL to browser history (\"true\", \"false\", or URL)\nhxreplaceurl!(el, value) — replace URL without history entry","category":"section"},{"location":"htmx/#User-Interaction","page":"HTMX Support","title":"User Interaction","text":"hxconfirm!(el, message) — show confirm() dialog before request\nhxprompt!(el, message) — show prompt() dialog before request\nhxindicator!(el, selector) — element to show during request","category":"section"},{"location":"htmx/#Progressive-Enhancement-and-Parameters","page":"HTMX Support","title":"Progressive Enhancement and Parameters","text":"hxboost!(el, value) — progressively enhance links/forms (\"true\"/\"false\")\nhxinclude!(el, selector) — include values of other elements\nhxparams!(el, value) — filter request parameters (\"*\", \"none\", list, \"not ...\")\nhxheaders!(el, json) — additional request headers (JSON string)\nhxsync!(el, value) — synchronize requests (\"closest form:abort\", \"this:drop\", etc.)\nhxencoding!(el, encoding) — request encoding (default: \"multipart/form-data\")\nhxext!(el, extensions) — enable htmx extensions (comma-separated)","category":"section"},{"location":"htmx/#Event-Handling","page":"HTMX Support","title":"Event Handling","text":"hxon!(el, event, script) — inline event handler via data-hx-on:<event>:\n\nhxon!(el, \"click\", \"alert('clicked!')\")\n# → data-hx-on:click=\"alert('clicked!')\"","category":"section"},{"location":"htmx/#Disabling-and-Inheritance","page":"HTMX Support","title":"Disabling and Inheritance","text":"hxdisable!(el) — disable htmx processing on element and children\nhxdisabledelt!(el, selector) — disable elements during request\nhxdisinherit!(el, attrs) — disable attribute inheritance (\"*\" or space-separated list)\nhxinherit!(el, attrs) — enable attribute inheritance","category":"section"},{"location":"htmx/#History-and-Preservation","page":"HTMX Support","title":"History and Preservation","text":"hxhistory!(el, value) — control history caching (\"false\" to prevent)\nhxhistoryelt!(el) — mark as history snapshot source\nhxpreserve!(el) — keep element unchanged between requests (needs stable id)","category":"section"},{"location":"htmx/#Request-Configuration-and-Validation","page":"HTMX Support","title":"Request Configuration and Validation","text":"hxrequestconfig!(el, value) — configure request (\"timeout:3000, credentials:true\")\nhxvalidate!(el) — enable HTML5 validation before request","category":"section"},{"location":"htmx/#Chaining-Example","page":"HTMX Support","title":"Chaining Example","text":"All htmx helpers return the element, so they can be chained:\n\nel = HTMLElement(:button)\nel |> x -> hxpost!(x, \"/submit\") |>\n     x -> hxtarget!(x, \"#result\") |>\n     x -> hxswap!(x, \"outerHTML\") |>\n     x -> hxconfirm!(x, \"Are you sure?\")\n\nnote: Note\nFor a much more ergonomic chaining experience, see the Experimental HTMX pipe DSL.","category":"section"},{"location":"#HTMLForge.jl","page":"Home","title":"HTMLForge.jl","text":"(Image: Stable) (Image: Dev) (Image: codecov)\n\nHTMLForge.jl is a Julia wrapper around the Gumbo library for parsing HTML, with first-class support for HTMX attributes.\n\nHTMLForge is a fork of the Gumbo.jl project, extended with HTMX types, functions, and syntax sugar for building interactive web UIs from Julia.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Full HTML parsing via Gumbo — handles real-world, messy HTML gracefully\nRich type system — HTMLDocument, HTMLElement{T}, HTMLText, NullNode\nTree traversal — pre-order, post-order, breadth-first iterators\nElement manipulation — find, modify, add/remove CSS classes\nHTMX first-class support — 30+ typed helpers for every htmx attribute\nExperimental HTMX DSL — macro and pipe-based interfaces that compress 625 LOC into <100","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using HTMLForge\n\n# Parse HTML\ndoc = parsehtml(\"<h1>Hello, world!</h1>\")\n\n# Create elements with HTMX\nel = HTMLElement(:button)\nhxpost!(el, \"/api/submit\")\nhxtarget!(el, \"#result\")\nhxswap!(el, \"outerHTML\")\nhxconfirm!(el, \"Are you sure?\")","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"HTMLForge\")\n\nOr in Pkg mode (]):\n\nadd HTMLForge","category":"section"},{"location":"parsing/#Parsing","page":"Parsing","title":"Parsing","text":"","category":"section"},{"location":"parsing/#Full-Document-Parsing","page":"Parsing","title":"Full Document Parsing","text":"parsehtml(html_string; strict=false, preserve_whitespace=false, preserve_template=false, include_parent=true)\n\nThe workhorse function. Takes a valid UTF-8 string and returns an HTMLDocument:\n\ndoc = parsehtml(\"<h1>Hello, world!</h1>\")","category":"section"},{"location":"parsing/#Keyword-arguments","page":"Parsing","title":"Keyword arguments","text":"Keyword Type Default Description\nstrict Bool false Throw InvalidHTMLException on parse errors\npreserve_whitespace Bool false Keep whitespace text nodes (e.g. inside <pre>)\npreserve_template Bool false Preserve <template> elements in the tree\ninclude_parent Bool true Set parent references on child nodes\n\nHTMLForge is a very permissive parser — it will produce valid HTML for any input. If you want strict validation, use strict=true.","category":"section"},{"location":"parsing/#Snippet-Parsing","page":"Parsing","title":"Snippet Parsing","text":"parsehtml_snippet(html_string; preserve_whitespace=false, preserve_template=false)\n\nParses an HTML fragment (not a full document) and returns an HTMLElement:\n\nel = parsehtml_snippet(\"<p>Hello</p>\")\n\nIf the snippet contains multiple top-level tags, they are wrapped in a <div>:\n\nel = parsehtml_snippet(\"<p>A</p><p>B</p>\")\n# → HTMLElement{:div} with two <p> children\n\nAccepts the same preserve_whitespace and preserve_template keyword arguments as parsehtml.","category":"section"},{"location":"types/#HTML-Types","page":"HTML Types","title":"HTML Types","text":"HTMLForge defines a type hierarchy for representing HTML documents.","category":"section"},{"location":"types/#Type-Hierarchy","page":"HTML Types","title":"Type Hierarchy","text":"HTMLNode (abstract)\n├── HTMLElement{T}   — an element with tag T (e.g. HTMLElement{:div})\n├── HTMLText         — text content\n└── NullNode         — sentinel for missing parents","category":"section"},{"location":"types/#HTMLDocument","page":"HTML Types","title":"HTMLDocument","text":"Returned by parsehtml. Has two fields:\n\ndoctype::AbstractString — the doctype of the parsed document (empty string if none)\nroot::HTMLElement — the root element of the document tree\n\ndoc = parsehtml(\"<html><body><p>Hi</p></body></html>\")\ndoc.doctype  # \"\"\ndoc.root     # HTMLElement{:HTML}","category":"section"},{"location":"types/#HTMLElement{T}","page":"HTML Types","title":"HTMLElement{T}","text":"The core type, parametrized by a Symbol representing its tag:\n\nmutable struct HTMLElement{T} <: HTMLNode\n    children::Vector{HTMLNode}\n    parent::HTMLNode\n    attributes::Dict{AbstractString, AbstractString}\nend","category":"section"},{"location":"types/#Constructors","page":"HTML Types","title":"Constructors","text":"# Empty element\nHTMLElement(:div)\n\n# Element with a single child\nHTMLElement(:div, HTMLText(\"hello\"))\n\n# Element with children and attributes\nHTMLElement(:p, [HTMLText(\"text\")], Dict(\"class\" => \"intro\"))\n\n# Element with children and keyword attributes (underscores become hyphens)\nHTMLElement(:div, HTMLNode[]; data_id=\"42\", class=\"box\")","category":"section"},{"location":"types/#Indexing","page":"HTML Types","title":"Indexing","text":"HTMLElement supports both integer indexing (children) and string/symbol indexing (attributes):\n\nel = HTMLElement(:div)\nel[\"class\"] = \"wide\"   # set attribute\nel[:class]             # get attribute → \"wide\"\nel[1]                  # first child","category":"section"},{"location":"types/#HTMLText","page":"HTML Types","title":"HTMLText","text":"Represents text content within an HTML document:\n\nmutable struct HTMLText <: HTMLNode\n    parent::HTMLNode\n    text::AbstractString\nend\n\nHTMLText(\"Example text\")\n\nConstructed text nodes have a NullNode parent by default.","category":"section"},{"location":"types/#NullNode","page":"HTML Types","title":"NullNode","text":"A sentinel type used as the parent of root elements and detached nodes:\n\nstruct NullNode <: HTMLNode end","category":"section"}]
}
